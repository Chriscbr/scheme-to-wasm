use crate::common::{
    transform_typed_exp_recursive, transform_typed_prog_recursive, ExprKind, Prog, TypedExpr,
};
use crate::types::{type_var_substitute_recursive, Type};
use im_rc::vector;

#[derive(Clone, Debug)]
pub struct PackElimError(String);

// Allows other errors to wrap this one
impl std::error::Error for PackElimError {}

impl From<&str> for PackElimError {
    fn from(message: &str) -> Self {
        PackElimError(String::from(message))
    }
}

impl std::fmt::Display for PackElimError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "PackElimError: {}", self.0)
    }
}

/// Convert an expression into one without pack or unpack expressions.
///
/// Conversion is performed by merely stripping out all of the extra type
/// information inserted by "pack" and "unpack" expressions.
///
/// The purpose of this compiler pass is to strip out existential type
/// information that cannot be embedded in WebAssembly in any clear / immediate
/// form (though it is possible this could be added later). To be clear,
/// this compiler pass _does_ strip away meaningful type information, and hence
/// isn't necessarily type safe on any arbitrary type-checked expression of the
/// language grammar/semantics.
///
/// Expression must be type checked (annotated with types) before being passed
/// in. After conversion, the output expression of this function will have all
/// type annotations removed, so it should be re-type-checked.
///
/// Example:
///
/// (unpack (temp0
///          (pack (make-tuple
///                 (lambda ((env1 : (record)) (x : int)) : int (+ x 1))
///                 (make-record))
///                (record)
///                (exists T2 (tuple (-> T2 int int) T2)))
///          T3)
///         ((tuple-ref temp0 0)
///          (tuple-ref temp0 1)
///          5))
///
/// will get converted to:
///
/// (let ((temp0 (make-tuple
///               (lambda ((env1 : (record)) (x : int)) : int (+ x 1))
///               (make-record))))
///   ((tuple-ref temp0 0)
///    (tuple-ref temp0 1)
///    5))
///
/// In *general*, this may not always be possible because we need to convert
/// the type substitution variable named by `unpack` with whatever type
/// the pack expression is satisfied by, which may not always be immediately
/// available. In the example above, this means the expression
/// ((tuple-ref temp0 0) (tuple-ref temp0 1) 5) could have been expression
/// using T3 (where T3 refers to whatever the "hidden" existential type is),
/// and the satisfying type, in this case "(record)", might not be available
/// if pack was created elsewhere (i.e. not directly nested inside).
///
/// However, we are assuming we are just dealing with expressions generated
/// by our compiler, and so we will make the assumption that none of the
/// bodies of unpack expressions will actually use the type variable field,
/// hence no substitutions (which would require internal information of the
/// hidden type of the pack expression) will be needed.
pub fn pack_elim_exp(exp: &TypedExpr) -> Result<TypedExpr, PackElimError> {
    transform_typed_exp_recursive(exp, pe_helper, pe_type_helper)
}

/// Convert a program into one without pack or unpack expressions.
///
/// See `pack_elim_exp` for more specific details.
pub fn pack_elim_prog(prog: &Prog<TypedExpr>) -> Result<Prog<TypedExpr>, PackElimError> {
    transform_typed_prog_recursive(prog, pe_helper, pe_type_helper)
}

fn pe_type_helper(typ: &Type) -> Option<Result<Type, PackElimError>> {
    match typ {
        // An existential type by itself doesn't provide us with enough
        // information to convert it into a different type - so this type
        // transformation isn't *generally* safe.
        //
        // However, this compile pass assumes that the only occurrences
        // of existential types are those within pack expressions that were
        // generated by closure conversion.
        //
        // This is because (unpack (pack <exp> <exist-type>) ...) will get
        // converted into just <exp>, so the existential type is just dropped!
        Type::Exists(_type_var, _base_type) => Some(Ok(Type::Unknown)),

        // There shouldn't be any type variables after this compiler pass
        // is executed on an expression, but I'll leave this in case type
        // variables get used for some other purpose, e.g. universal quantified
        // types.
        Type::TypeVar(x) => Some(Ok(Type::TypeVar(*x))),
        _ => None,
    }
}

fn pe_helper(exp: &TypedExpr) -> Option<Result<TypedExpr, PackElimError>> {
    match &*exp.kind {
        ExprKind::Pack(val, _sub, _exist) => {
            let pval = match pack_elim_exp(&val) {
                Ok(val) => val,
                Err(e) => return Some(Err(e)),
            };
            Some(Ok(pval))
        }
        ExprKind::Unpack(var, package, type_sub, body) => {
            let hidden_type = match &*package.kind {
                ExprKind::Pack(_pack_body, pack_type_sub, _pack_exist_type) => {
                    pack_type_sub.clone()
                },
                // ExprKind::Id(name) => {

                // }
                _ => return Some(Err(PackElimError::from("Unpack does not directly contain a package inside. Safe package elimination is therefore not possible."))),
            };
            let pbody = match pack_elim_exp(&body) {
                Ok(val) => val,
                Err(e) => return Some(Err(e)),
            };
            // Here, we type substitute the package's "hidden" type for the
            // type variables corresponding to the type-var field in the
            // unpack expression, wherever it occurs within the body of
            // this expression.
            //
            // This is necessary since otherwise we will end up simplifying
            // like
            //   (unpack (temp0 <package-of-tuple> T3) as (temp0.0 temp0.1 5))
            // into
            //   (let ((temp0 <tuple>)) (temp0.0 temp0.1 5))
            // which is correct, except that temp0 and its fields will be
            // type annotated with respect to type variable T3 instead of
            // the hidden type (the type of the closure environment).
            let pbody = match type_var_substitute_recursive(&pbody, *type_sub, &hidden_type) {
                Ok(val) => val,
                Err(e) => return Some(Err(PackElimError(format!("{}", e)))),
            };
            let ppackage = match pack_elim_exp(&package) {
                Ok(val) => val,
                Err(e) => return Some(Err(e)),
            };
            Some(Ok(TypedExpr::new(
                pbody.typ.clone(),
                ExprKind::Let(vector![(var.clone(), ppackage)], pbody),
            )))
        }
        _ => None,
    }
}
